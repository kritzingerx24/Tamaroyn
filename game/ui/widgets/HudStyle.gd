class_name HudStyle
extends RefCounted

# Centralized HUD styling helpers (Wulfram-II inspired).
# All values are tuned for readability first; we can later replace the panel look with real UI textures.

# Palette
const ACCENT: Color = Color(0.95, 0.62, 0.22, 0.95)      # warm orange
const ACCENT_SOFT: Color = Color(0.95, 0.62, 0.22, 0.55)
const TEXT: Color = Color(0.97, 0.92, 0.78, 0.95)
const TEXT_MUTED: Color = Color(0.88, 0.82, 0.70, 0.78)
const PANEL_BG: Color = Color(0.08, 0.06, 0.05, 0.78)
const PANEL_BG_INNER: Color = Color(0.12, 0.09, 0.06, 0.82)
const EDGE_DARK: Color = Color(0.00, 0.00, 0.00, 0.85)
const EDGE_LIGHT: Color = Color(1.00, 0.95, 0.80, 0.10)

const OK: Color = Color(0.45, 1.00, 0.60, 0.95)
const BAD: Color = Color(1.00, 0.45, 0.45, 0.95)

# Wulfram bitmap UI textures live here (generated by tools/extract_wulfram_bitmaps.py).
const UI_DIR: String = "res://assets/wulfram_textures/extracted/"
static var _tex_cache: Dictionary = {}

static func tex(name: String) -> Texture2D:
	# Loads UI textures by base name ("menubar") or filename ("menubar.png").
	if name.is_empty():
		return null
	var key: String = name
	if _tex_cache.has(key):
		return _tex_cache[key]
	var file: String = name
	if not file.to_lower().ends_with(".png"):
		file += ".png"
	var path: String = UI_DIR + file
	var t: Texture2D = null
	if ResourceLoader.exists(path):
		t = load(path) as Texture2D
	_tex_cache[key] = t
	return t

static func _mk_panel_style(accent: Color = ACCENT) -> StyleBoxFlat:
	var sb: StyleBoxFlat = StyleBoxFlat.new()
	sb.bg_color = PANEL_BG_INNER
	sb.border_color = EDGE_DARK
	sb.border_width_all = 2
	sb.corner_radius_top_left = 7
	sb.corner_radius_top_right = 7
	sb.corner_radius_bottom_left = 7
	sb.corner_radius_bottom_right = 7
	sb.shadow_color = Color(0, 0, 0, 0.55)
	sb.shadow_size = 6
	# Slightly larger padding to match the chunky Wulfram HUD feel.
	sb.content_margin_left = 8
	sb.content_margin_right = 8
	sb.content_margin_top = 8
	sb.content_margin_bottom = 8
	# Thin accent line at the top (drawn as a border tint).
	sb.border_color = EDGE_DARK
	return sb

static func apply_panel(n: Control, accent: Color = ACCENT) -> void:
	if n == null:
		return
	# Panels use the "panel" stylebox slot.
	n.add_theme_stylebox_override("panel", _mk_panel_style(accent))

static func apply_progressbar(pb: ProgressBar, accent: Color = ACCENT) -> void:
	if pb == null:
		return
	# Background
	var bg: StyleBoxFlat = StyleBoxFlat.new()
	bg.bg_color = Color(0.00, 0.00, 0.00, 0.35)
	bg.border_color = Color(1, 1, 1, 0.10)
	bg.border_width_all = 1
	bg.corner_radius_top_left = 3
	bg.corner_radius_top_right = 3
	bg.corner_radius_bottom_left = 3
	bg.corner_radius_bottom_right = 3
	pb.add_theme_stylebox_override("background", bg)

	# Fill
	var fill: StyleBoxFlat = StyleBoxFlat.new()
	fill.bg_color = Color(accent.r, accent.g, accent.b, 0.85)
	fill.border_color = Color(1, 1, 1, 0.10)
	fill.border_width_all = 0
	fill.corner_radius_top_left = 3
	fill.corner_radius_top_right = 3
	fill.corner_radius_bottom_left = 3
	fill.corner_radius_bottom_right = 3
	pb.add_theme_stylebox_override("fill", fill)

static func apply_label(lbl: Label, muted: bool = false) -> void:
	if lbl == null:
		return
	lbl.add_theme_color_override("font_color", TEXT_MUTED if muted else TEXT)

static func draw_panel_back(c: Control, rect: Rect2, accent: Color = ACCENT) -> void:
	# Used by procedural widgets (BuildPanel/MiniMap/TargetPanel) to mimic the same panel skin.
	# Prefer real Wulfram UI textures when present; fall back to the procedural skin.
	var bg_tex: Texture2D = tex("barnotch_lo")
	var top_tex: Texture2D = tex("barnotch_hi")
	if bg_tex != null:
		c.draw_texture_rect(bg_tex, rect, true, Color(1, 1, 1, 0.90))
		# Darken slightly so gameplay stays readable over the tiling.
		c.draw_rect(rect, Color(0, 0, 0, 0.28), true)
		# Top strip (gives the classic chunky HUD edge).
		if top_tex != null:
			var th: float = min(float(top_tex.get_height()), rect.size.y)
			c.draw_texture_rect(top_tex, Rect2(rect.position, Vector2(rect.size.x, th)), true, Color(1, 1, 1, 0.85))
	else:
		c.draw_rect(rect, PANEL_BG, true)
		# Inner bevel
		c.draw_rect(rect.grow(-2.0), PANEL_BG_INNER, true)

	# Dark outer edge
	c.draw_rect(rect, EDGE_DARK, false, 2.0)
	# Light inner edge
	c.draw_rect(rect.grow(-2.0), EDGE_LIGHT, false, 1.0)
	# Accent top line
	c.draw_line(Vector2(rect.position.x + 6.0, rect.position.y + 2.0), Vector2(rect.position.x + rect.size.x - 6.0, rect.position.y + 2.0), Color(accent.r, accent.g, accent.b, 0.65), 2.0)


static func draw_button_back(c: Control, rect: Rect2, state: int = 0, accent: Color = ACCENT) -> void:
	# Draw a Wulfram-ish button background. Used for weapon rows and build slots.
	# state: 0=normal, 1=selected, 2=dark/disabled
	var base: Texture2D = tex("pannel_map_hanging_button")
	if base != null:
		# The source is a thin strip; tiling preserves the crunchy bitmap feel.
		var a: float = 0.92
		if state == 2:
			a = 0.65
		c.draw_texture_rect(base, rect, true, Color(1, 1, 1, a))
		# Darken slightly for readability.
		c.draw_rect(rect, Color(0, 0, 0, 0.22), true)
	else:
		c.draw_rect(rect, PANEL_BG_INNER, true)

	if state == 1:
		# Selected: overlay a subtle menubar texture + accent line.
		var hi: Texture2D = tex("menubar")
		if hi != null:
			c.draw_texture_rect(hi, rect, true, Color(1, 1, 1, 0.35))
		c.draw_rect(rect, Color(accent.r, accent.g, accent.b, 0.28), true)
		c.draw_line(Vector2(rect.position.x + 4.0, rect.position.y + 2.0), Vector2(rect.position.x + rect.size.x - 4.0, rect.position.y + 2.0), Color(accent.r, accent.g, accent.b, 0.70), 2.0)
	elif state == 2:
		# Dark/disabled: heavier dim.
		c.draw_rect(rect, Color(0, 0, 0, 0.32), true)

	# Button outline
	c.draw_rect(rect, Color(0, 0, 0, 0.85), false, 1.0)
	c.draw_rect(rect.grow(-1.0), Color(1, 1, 1, 0.10), false, 1.0)
